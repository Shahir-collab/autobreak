# malware_detector_fixed.py
# Enhanced Malware Detection and Classification System with Penetration Testing
# College Project - Cybersecurity Educational Tool
# Supervised Academic Project
# Modified to fix KeyError in Test 3 and add robustness checks.
# Developer: Mohammed Shahir (+ fixes by assistant)

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.preprocessing import StandardScaler, LabelEncoder
import joblib
import os
import json
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

class EnhancedMalwareDetectionSystem:
    def __init__(self):
        self.binary_model = None
        self.multiclass_model = None
        self.binary_scaler = StandardScaler()
        self.multiclass_scaler = StandardScaler()
        self.label_encoder = LabelEncoder()
        self.binary_feature_columns = []
        self.multiclass_feature_columns = []
        self.malware_types = []
        self.feature_importances = {}
        
    def load_binary_dataset(self, filepath):
        """Load binary classification dataset (malware vs benign)"""
        try:
            df = pd.read_csv(filepath)
            print(f"Binary dataset loaded: {df.shape[0]} samples, {df.shape[1]} features")
            print(f"Dataset columns: {list(df.columns)}")
            if 'classification' in df.columns:
                print(f"Classification distribution:")
                print(df['classification'].value_counts())
            return df
        except Exception as e:
            print(f"Error loading binary dataset: {e}")
            return None
    
    def load_multiclass_dataset(self, filepath):
        """Load multiclass malware classification dataset"""
        try:
            df = pd.read_csv(filepath)
            print(f"Multiclass dataset loaded: {df.shape[0]} samples, {df.shape[1]} features")
            print(f"Dataset columns: {list(df.columns)}")
            if 'label' in df.columns:
                print(f"Malware types distribution:")
                print(df['label'].value_counts())
            return df
        except Exception as e:
            print(f"Error loading multiclass dataset: {e}")
            return None
    
    def preprocess_binary_data(self, df):
        """Clean and prepare binary classification data"""
        print("\n=== Preprocessing Binary Dataset ===")
        columns_to_drop = ['hash', 'millisecond']
        df_clean = df.drop(columns=columns_to_drop, errors='ignore').copy()
        df_clean = df_clean.fillna(0)
        if 'classification' not in df_clean.columns:
            raise ValueError("Binary dataset missing 'classification' column")
        df_clean['binary_target'] = (df_clean['classification'] == 'malware').astype(int)
        feature_cols = [col for col in df_clean.columns if col not in ['classification', 'binary_target']]
        X = df_clean[feature_cols]
        y = df_clean['binary_target']
        self.binary_feature_columns = feature_cols
        print(f"Binary features: {len(feature_cols)}")
        print(f"Feature columns: {feature_cols[:10]}...")
        print(f"Target distribution - Benign: {(y==0).sum()}, Malware: {(y==1).sum()}")
        return X, y, df_clean
    
    def preprocess_multiclass_data(self, df):
        """Clean and prepare multiclass malware data
        RETURNS: X, y, df_clean (so caller can use the processed DataFrame)
        """
        print("\n=== Preprocessing Multiclass Dataset ===")
        columns_to_drop = ['id', 'filename', 'created_at', 'sample_text']
        df_clean = df.drop(columns=columns_to_drop, errors='ignore').copy()
        df_clean = df_clean.fillna(0)
        if 'suspicious_strings' in df_clean.columns:
            df_clean['suspicious_strings_count'] = df_clean['suspicious_strings'].apply(
                lambda x: len(str(x).split(';')) if pd.notna(x) and str(x).strip() != '' else 0
            )
            df_clean = df_clean.drop(columns=['suspicious_strings'], errors='ignore')
        else:
            df_clean['suspicious_strings_count'] = df_clean.get('suspicious_strings_count', 0)
        if 'platform' in df_clean.columns:
            platform_encoder = LabelEncoder()
            df_clean['platform_encoded'] = platform_encoder.fit_transform(df_clean['platform'].fillna('unknown'))
            df_clean = df_clean.drop(columns=['platform'], errors='ignore')
        else:
            df_clean['platform_encoded'] = df_clean.get('platform_encoded', 0)
        if 'obfuscation_level' in df_clean.columns:
            obfuscation_map = {'none': 0, 'low': 1, 'medium': 2, 'high': 3}
            df_clean['obfuscation_level_encoded'] = df_clean['obfuscation_level'].map(obfuscation_map).fillna(0)
            df_clean = df_clean.drop(columns=['obfuscation_level'], errors='ignore')
        else:
            df_clean['obfuscation_level_encoded'] = df_clean.get('obfuscation_level_encoded', 0)
        if 'label' not in df_clean.columns:
            raise ValueError("Multiclass dataset missing 'label' column")
        feature_cols = [col for col in df_clean.columns if col != 'label']
        X = df_clean[feature_cols]
        y = df_clean['label']
        self.multiclass_feature_columns = feature_cols
        print(f"Multiclass features: {len(feature_cols)}")
        print(f"Feature columns: {feature_cols}")
        print(f"Malware types: {len(y.unique())}")
        print("Malware type distribution:")
        for malware_type, count in y.value_counts().items():
            print(f"  {malware_type}: {count}")
        return X, y, df_clean
    
    def train_binary_classifier(self, X, y):
        """Train binary malware detection model"""
        print("\n=== Training Binary Malware Detection Model ===")
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )
        X_train_scaled = self.binary_scaler.fit_transform(X_train)
        X_test_scaled = self.binary_scaler.transform(X_test)
        self.binary_model = RandomForestClassifier(
            n_estimators=200,
            max_depth=15,
            min_samples_split=10,
            min_samples_leaf=5,
            random_state=42,
            n_jobs=-1,
            class_weight='balanced'
        )
        self.binary_model.fit(X_train_scaled, y_train)
        y_pred = self.binary_model.predict(X_test_scaled)
        accuracy = accuracy_score(y_test, y_pred)
        try:
            self.feature_importances['binary'] = dict(zip(
                self.binary_feature_columns, 
                self.binary_model.feature_importances_
            ))
        except Exception:
            self.feature_importances['binary'] = {}
        print(f"Binary Classification Accuracy: {accuracy:.4f}")
        print("\nClassification Report:")
        print(classification_report(y_test, y_pred, target_names=['Benign', 'Malware']))
        top_features = sorted(self.feature_importances.get('binary', {}).items(), 
                            key=lambda x: x[1], reverse=True)[:10]
        if top_features:
            print("\nTop 10 Important Features for Binary Classification:")
            for feature, importance in top_features:
                print(f"  {feature}: {importance:.4f}")
        return accuracy
    
    def train_multiclass_classifier(self, X, y):
        """Train multiclass malware type classifier"""
        print("\n=== Training Multiclass Malware Classification Model ===")
        y_encoded = self.label_encoder.fit_transform(y)
        self.malware_types = self.label_encoder.classes_
        X_train, X_test, y_train, y_test = train_test_split(
            X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded
        )
        X_train_scaled = self.multiclass_scaler.fit_transform(X_train)
        X_test_scaled = self.multiclass_scaler.transform(X_test)
        self.multiclass_model = RandomForestClassifier(
            n_estimators=200,
            max_depth=20,
            min_samples_split=5,
            min_samples_leaf=2,
            random_state=42,
            n_jobs=-1,
            class_weight='balanced'
        )
        self.multiclass_model.fit(X_train_scaled, y_train)
        y_pred = self.multiclass_model.predict(X_test_scaled)
        accuracy = accuracy_score(y_test, y_pred)
        try:
            self.feature_importances['multiclass'] = dict(zip(
                self.multiclass_feature_columns, 
                self.multiclass_model.feature_importances_
            ))
        except Exception:
            self.feature_importances['multiclass'] = {}
        print(f"Multiclass Classification Accuracy: {accuracy:.4f}")
        print(f"Number of malware types: {len(self.malware_types)}")
        print(f"Malware types: {list(self.malware_types)}")
        y_test_labels = self.label_encoder.inverse_transform(y_test)
        y_pred_labels = self.label_encoder.inverse_transform(y_pred)
        print("\nMulticlass Classification Report:")
        print(classification_report(y_test_labels, y_pred_labels))
        top_features = sorted(self.feature_importances.get('multiclass', {}).items(), 
                            key=lambda x: x[1], reverse=True)[:10]
        if top_features:
            print("\nTop 10 Important Features for Multiclass Classification:")
            for feature, importance in top_features:
                print(f"  {feature}: {importance:.4f}")
        return accuracy
    
    def predict_comprehensive(self, sample_features, sample_name="Unknown", dataset_type="binary"):
        """Comprehensive prediction: binary + multiclass + penetration analysis"""
        if self.binary_model is None:
            return {"error": "Models not trained"}
        result = {
            "sample_name": sample_name,
            "timestamp": datetime.now().isoformat(),
            "binary_prediction": {},
            "multiclass_prediction": {},
            "penetration_analysis": {},
            "overall_assessment": {}
        }
        try:
            # === BINARY CLASSIFICATION ===
            if dataset_type == "binary" and len(sample_features) == len(self.binary_feature_columns):
                sample_scaled = self.binary_scaler.transform([sample_features])
                is_malware = self.binary_model.predict(sample_scaled)[0]
                malware_prob = self.binary_model.predict_proba(sample_scaled)[0][1]
                result["binary_prediction"] = {
                    "is_malware": bool(is_malware),
                    "malware_probability": float(malware_prob),
                    "confidence": "High" if abs(malware_prob - 0.5) > 0.3 else "Medium"
                }
            elif dataset_type == "multiclass":
                binary_features = self._map_multiclass_to_binary_features(sample_features)
                if binary_features is not None and len(binary_features) == len(self.binary_feature_columns):
                    sample_scaled = self.binary_scaler.transform([binary_features])
                    is_malware = self.binary_model.predict(sample_scaled)[0]
                    malware_prob = self.binary_model.predict_proba(sample_scaled)[0][1]
                    result["binary_prediction"] = {
                        "is_malware": bool(is_malware),
                        "malware_probability": float(malware_prob),
                        "confidence": "Medium (synthetic mapping)",
                        "note": "Binary prediction based on mapped features"
                    }
                else:
                    result["binary_prediction"] = {
                        "is_malware": True,
                        "malware_probability": 0.95,
                        "confidence": "Assumed (multiclass sample)",
                        "note": "Sample from malware classification dataset"
                    }
            # === MULTICLASS CLASSIFICATION ===
            if self.multiclass_model is not None:
                if dataset_type == "multiclass" and len(sample_features) == len(self.multiclass_feature_columns):
                    multiclass_scaled = self.multiclass_scaler.transform([sample_features])
                    malware_type_idx = self.multiclass_model.predict(multiclass_scaled)[0]
                    try:
                        malware_type = self.malware_types[malware_type_idx]
                    except Exception:
                        malware_type = str(malware_type_idx)
                    type_probs = self.multiclass_model.predict_proba(multiclass_scaled)[0]
                    top_indices = np.argsort(type_probs)[-3:][::-1]
                    top_predictions = [
                        {
                            "type": self.malware_types[idx],
                            "probability": float(type_probs[idx])
                        }
                        for idx in top_indices
                    ]
                    result["multiclass_prediction"] = {
                        "primary_type": malware_type,
                        "confidence": float(max(type_probs)),
                        "top_predictions": top_predictions,
                        "total_types_analyzed": len(self.malware_types)
                    }
                elif dataset_type == "binary" and result["binary_prediction"].get("is_malware", False):
                    multiclass_features = self._map_binary_to_multiclass_features(sample_features)
                    if multiclass_features is not None and len(multiclass_features) == len(self.multiclass_feature_columns):
                        multiclass_scaled = self.multiclass_scaler.transform([multiclass_features])
                        malware_type_idx = self.multiclass_model.predict(multiclass_scaled)[0]
                        try:
                            malware_type = self.malware_types[malware_type_idx]
                        except Exception:
                            malware_type = str(malware_type_idx)
                        type_probs = self.multiclass_model.predict_proba(multiclass_scaled)[0]
                        top_indices = np.argsort(type_probs)[-3:][::-1]
                        top_predictions = [
                            {
                                "type": self.malware_types[idx],
                                "probability": float(type_probs[idx])
                            }
                            for idx in top_indices
                        ]
                        result["multiclass_prediction"] = {
                            "primary_type": malware_type,
                            "confidence": float(max(type_probs)),
                            "top_predictions": top_predictions,
                            "note": "Classification based on mapped features"
                        }
            # === PENETRATION TESTING ANALYSIS ===
            result["penetration_analysis"] = self._perform_penetration_analysis(
                sample_features, result, dataset_type
            )
            # === OVERALL ASSESSMENT ===
            result["overall_assessment"] = self._generate_overall_assessment(result)
        except Exception as e:
            result["error"] = f"Prediction error: {str(e)}"
        return result
    
    def _map_binary_to_multiclass_features(self, binary_features):
        """Map binary features to multiclass features"""
        try:
            if len(self.multiclass_feature_columns) == 0:
                return None
            multiclass_features = []
            feature_mapping = {
                'filesize_bytes': float(binary_features[3]) if len(binary_features) > 3 else float(np.random.randint(1000, 1000000)),
                'entropy': float(np.random.uniform(1.0, 8.0)),
                'import_count': int(binary_features[1]) if len(binary_features) > 1 else int(np.random.randint(1, 20)),
                'has_packed': int(np.random.randint(0, 2)),
                'strings_count': int(binary_features[2]) if len(binary_features) > 2 else int(np.random.randint(10, 1000)),
                'api_calls_count': int(binary_features[4]) if len(binary_features) > 4 else int(np.random.randint(10, 50)),
                'permission_count': int(np.random.randint(1, 10)),
                'network_activity': int(np.random.randint(0, 2)),
                'domain_count': int(np.random.randint(0, 5)),
                'ip_count': int(np.random.randint(0, 5)),
                'platform_encoded': int(np.random.randint(0, 4)),
                'obfuscation_level_encoded': int(np.random.randint(0, 4)),
                'suspicious_strings_count': int(np.random.randint(1, 10))
            }
            for col in self.multiclass_feature_columns:
                if col in feature_mapping:
                    multiclass_features.append(feature_mapping[col])
                else:
                    base_idx = len(multiclass_features) % max(1, len(binary_features))
                    variation = float(binary_features[base_idx]) * (1 + float(np.random.normal(0, 0.1)))
                    multiclass_features.append(variation)
            return np.array(multiclass_features, dtype=float)
        except Exception as e:
            print(f"Feature mapping error: {e}")
            return None
    
    def _map_multiclass_to_binary_features(self, multiclass_features):
        """Map multiclass features to binary features"""
        try:
            if len(self.binary_feature_columns) == 0:
                return None
            binary_features = []
            multiclass_dict = dict(zip(self.multiclass_feature_columns, multiclass_features))
            for col in self.binary_feature_columns:
                if col in multiclass_dict:
                    binary_features.append(multiclass_dict[col])
                else:
                    synthetic_value = float(np.mean(multiclass_features)) * (1 + float(np.random.normal(0, 0.1)))
                    binary_features.append(synthetic_value)
            return np.array(binary_features, dtype=float)
        except Exception as e:
            print(f"Reverse feature mapping error: {e}")
            return None
    
    def _perform_penetration_analysis(self, features, prediction_result, dataset_type):
        """Perform comprehensive penetration testing analysis"""
        vulnerabilities = []
        attack_vectors = []
        penetration_score = 0
        if dataset_type == "multiclass":
            penetration_score, vulnerabilities, attack_vectors = self._analyze_multiclass_features(features)
        else:
            penetration_score, vulnerabilities, attack_vectors = self._analyze_binary_features(features)
        if prediction_result["binary_prediction"].get("is_malware", False):
            penetration_score += 40
            attack_vectors.append("Known malware behavior patterns detected")
            if "primary_type" in prediction_result.get("multiclass_prediction", {}):
                malware_type = prediction_result["multiclass_prediction"]["primary_type"]
                penetration_score += self._get_malware_type_risk(malware_type)
                attack_vectors.append(f"Specific {malware_type} attack patterns identified")
        pen_test_recommendations = self._generate_penetration_recommendations(
            vulnerabilities, attack_vectors, penetration_score
        )
        return {
            "penetration_score": min(penetration_score, 100),
            "vulnerability_count": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "attack_vectors": attack_vectors,
            "penetration_level": self._get_penetration_level(penetration_score),
            "recommendations": pen_test_recommendations,
            "defensive_measures": self._suggest_defensive_measures(vulnerabilities)
        }
    
    def _analyze_multiclass_features(self, features):
        """Analyze multiclass dataset features for penetration testing"""
        vulnerabilities = []
        attack_vectors = []
        score = 0
        if len(features) < len(self.multiclass_feature_columns):
            return score, vulnerabilities, attack_vectors
        feature_dict = dict(zip(self.multiclass_feature_columns, features))
        filesize = feature_dict.get('filesize_bytes', 0)
        if filesize > 1000000:
            vulnerabilities.append("Large file size - potential for hidden payloads")
            score += 15
        elif filesize < 1000:
            vulnerabilities.append("Unusually small file - potential packer/dropper")
            score += 10
        entropy = feature_dict.get('entropy', 0)
        if entropy > 7.5:
            vulnerabilities.append("High entropy - strong indication of encryption/packing")
            attack_vectors.append("Packed malware evasion technique")
            score += 25
        elif entropy < 1.5:
            vulnerabilities.append("Very low entropy - potential simple obfuscation")
            score += 10
        import_count = feature_dict.get('import_count', 0)
        if import_count > 15:
            vulnerabilities.append("High import count - complex functionality")
            attack_vectors.append("Multiple API exploitation vectors")
            score += 15
        has_packed = feature_dict.get('has_packed', 0)
        if has_packed:
            vulnerabilities.append("Packed executable detected")
            attack_vectors.append("Anti-analysis evasion")
            score += 20
        network_activity = feature_dict.get('network_activity', 0)
        if network_activity:
            vulnerabilities.append("Network communication capability")
            attack_vectors.append("Data exfiltration/C&C communication")
            score += 20
        obfuscation = feature_dict.get('obfuscation_level_encoded', 0)
        if obfuscation >= 2:
            vulnerabilities.append("Advanced obfuscation detected")
            attack_vectors.append("Analysis evasion techniques")
            score += 25
        return score, vulnerabilities, attack_vectors
    
    def _analyze_binary_features(self, features):
        """Analyze binary dataset features for penetration testing"""
        vulnerabilities = []
        attack_vectors = []
        score = 0
        if len(features) == 0:
            return score, vulnerabilities, attack_vectors
        feature_stats = {
            'mean': np.mean(features),
            'std': np.std(features),
            'max': np.max(features),
            'min': np.min(features)
        }
        if feature_stats['std'] > feature_stats['mean']:
            vulnerabilities.append("High feature variance - inconsistent behavior")
            score += 15
        if feature_stats['max'] > 1000000:
            vulnerabilities.append("Extreme feature values detected")
            attack_vectors.append("Resource exhaustion potential")
            score += 20
        if len(features) > 10:
            memory_indicators = features[10:15]
            if np.mean(memory_indicators) > 10000:
                vulnerabilities.append("High memory usage patterns")
                attack_vectors.append("Memory-based attack vectors")
                score += 15
        if len(features) > 20:
            process_indicators = features[20:25]
            if np.sum(process_indicators) > 100000:
                vulnerabilities.append("Intensive process activity")
                attack_vectors.append("Process injection/manipulation")
                score += 18
        return score, vulnerabilities, attack_vectors
    
    def _get_malware_type_risk(self, malware_type):
        """Get additional risk score based on malware type"""
        if not isinstance(malware_type, str):
            try:
                malware_type = str(malware_type)
            except:
                malware_type = ""
        risk_scores = {
            'ransomware': 35,
            'trojan': 30,
            'rootkit': 30,
            'spyware': 25,
            'worm': 20,
            'adware': 10,
            'botnet': 25,
            'phishing': 15
        }
        return risk_scores.get(malware_type.lower(), 15)
    
    def _get_penetration_level(self, score):
        """Determine penetration testing level based on score"""
        if score >= 80:
            return "Critical - Advanced Persistent Threat"
        elif score >= 60:
            return "High - Sophisticated Attack"
        elif score >= 40:
            return "Medium - Standard Malware"
        elif score >= 20:
            return "Low - Basic Threat"
        else:
            return "Minimal - Low Risk"
    
    def _generate_penetration_recommendations(self, vulnerabilities, attack_vectors, score):
        """Generate penetration testing recommendations"""
        recommendations = []
        if score >= 80:
            recommendations.extend([
                "🚨 CRITICAL: Implement immediate containment procedures",
                "Deploy advanced endpoint detection and response (EDR)",
                "Conduct forensic analysis of affected systems",
                "Review network segmentation and access controls"
            ])
        elif score >= 60:
            recommendations.extend([
                "⚠️ HIGH RISK: Enhanced monitoring required",
                "Implement behavioral analysis tools",
                "Review and update security policies",
                "Conduct targeted threat hunting"
            ])
        elif score >= 40:
            recommendations.extend([
                "🔍 MEDIUM RISK: Standard security measures",
                "Regular vulnerability assessments",
                "Update security awareness training",
                "Monitor for indicators of compromise"
            ])
        else:
            recommendations.extend([
                "✅ STANDARD: Maintain current security posture",
                "Continue regular security monitoring",
                "Keep systems updated and patched"
            ])
        if any("entropy" in str(v).lower() for v in vulnerabilities):
            recommendations.append("Deploy unpacking and decryption tools")
        if any("network" in str(v).lower() for v in vulnerabilities):
            recommendations.append("Implement network traffic analysis")
        if any("obfuscation" in str(v).lower() for v in vulnerabilities):
            recommendations.append("Use advanced static analysis tools")
        return recommendations
    
    def _suggest_defensive_measures(self, vulnerabilities):
        """Suggest specific defensive measures"""
        measures = [
            "Implement application whitelisting",
            "Enable real-time behavioral monitoring",
            "Deploy honeypots for threat detection",
            "Regular security awareness training",
            "Implement zero-trust architecture"
        ]
        if any("memory" in str(v).lower() for v in vulnerabilities):
            measures.append("Implement memory protection mechanisms (ASLR, DEP)")
        if any("process" in str(v).lower() for v in vulnerabilities):
            measures.append("Deploy process monitoring and sandboxing")
        if any("network" in str(v).lower() for v in vulnerabilities):
            measures.append("Implement network segmentation and DPI")
        return measures
    
    def _generate_overall_assessment(self, result):
        """Generate comprehensive overall assessment"""
        binary_threat = 50 if result["binary_prediction"].get("is_malware", False) else 0
        multiclass_threat = result.get("multiclass_prediction", {}).get("confidence", 0) * 30
        penetration_threat = result["penetration_analysis"]["penetration_score"] * 0.2
        overall_score = binary_threat + multiclass_threat + penetration_threat
        if overall_score >= 80:
            threat_level = "CRITICAL"
            action = "IMMEDIATE ISOLATION REQUIRED"
        elif overall_score >= 60:
            threat_level = "HIGH"
            action = "QUARANTINE AND ANALYZE"
        elif overall_score >= 40:
            threat_level = "MEDIUM"
            action = "MONITOR CLOSELY"
        elif overall_score >= 20:
            threat_level = "LOW"
            action = "STANDARD MONITORING"
        else:
            threat_level = "MINIMAL"
            action = "CONTINUE NORMAL OPERATIONS"
        return {
            "overall_threat_score": min(overall_score, 100),
            "threat_level": threat_level,
            "recommended_action": action,
            "summary": self._generate_executive_summary(result, threat_level)
        }
    
    def _generate_executive_summary(self, result, threat_level):
        """Generate executive summary of analysis"""
        is_malware = result["binary_prediction"].get("is_malware", False)
        malware_type = result.get("multiclass_prediction", {}).get("primary_type", "Unknown")
        vuln_count = result["penetration_analysis"]["vulnerability_count"]
        if is_malware:
            if malware_type != "Unknown":
                summary = f"MALWARE DETECTED: {malware_type.upper()} identified with {vuln_count} vulnerabilities. "
            else:
                summary = f"MALWARE DETECTED: Type classification pending with {vuln_count} vulnerabilities. "
        else:
            summary = f"BENIGN FILE: Analysis reveals {vuln_count} potential vulnerabilities. "
        summary += f"Overall threat level: {threat_level}."
        return summary
    
    def save_models(self, filepath_prefix="enhanced_malware_models"):
        """Save all trained models and metadata"""
        try:
            if self.binary_model is not None:
                joblib.dump(self.binary_model, f"{filepath_prefix}_binary.pkl")
            if self.multiclass_model is not None:
                joblib.dump(self.multiclass_model, f"{filepath_prefix}_multiclass.pkl")
            if self.binary_scaler is not None:
                joblib.dump(self.binary_scaler, f"{filepath_prefix}_binary_scaler.pkl")
            if self.multiclass_scaler is not None:
                joblib.dump(self.multiclass_scaler, f"{filepath_prefix}_multiclass_scaler.pkl")
            if self.label_encoder is not None:
                joblib.dump(self.label_encoder, f"{filepath_prefix}_label_encoder.pkl")
            metadata = {
                "binary_feature_columns": self.binary_feature_columns,
                "multiclass_feature_columns": self.multiclass_feature_columns,
                "malware_types": list(self.malware_types) if self.malware_types is not None else [],
                "feature_importances": self.feature_importances,
                "timestamp": datetime.now().isoformat(),
                "model_info": {
                    "binary_features": len(self.binary_feature_columns),
                    "multiclass_features": len(self.multiclass_feature_columns),
                    "num_malware_types": len(self.malware_types) if self.malware_types is not None else 0
                }
            }
            with open(f"{filepath_prefix}_metadata.json", 'w') as f:
                json.dump(metadata, f, indent=2)
            print(f"✅ Enhanced models saved with prefix: {filepath_prefix}")
        except Exception as e:
            print(f"❌ Error saving models: {e}")
    
    def load_models(self, filepath_prefix="enhanced_malware_models"):
        """Load trained models and metadata"""
        try:
            binary_path = f"{filepath_prefix}_binary.pkl"
            multiclass_path = f"{filepath_prefix}_multiclass.pkl"
            binary_scaler_path = f"{filepath_prefix}_binary_scaler.pkl"
            multiclass_scaler_path = f"{filepath_prefix}_multiclass_scaler.pkl"
            label_encoder_path = f"{filepath_prefix}_label_encoder.pkl"
            metadata_path = f"{filepath_prefix}_metadata.json"
            if os.path.exists(binary_path):
                self.binary_model = joblib.load(binary_path)
            if os.path.exists(multiclass_path):
                self.multiclass_model = joblib.load(multiclass_path)
            if os.path.exists(binary_scaler_path):
                self.binary_scaler = joblib.load(binary_scaler_path)
            if os.path.exists(multiclass_scaler_path):
                self.multiclass_scaler = joblib.load(multiclass_scaler_path)
            if os.path.exists(label_encoder_path):
                self.label_encoder = joblib.load(label_encoder_path)
            if os.path.exists(metadata_path):
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                self.binary_feature_columns = metadata.get("binary_feature_columns", [])
                self.multiclass_feature_columns = metadata.get("multiclass_feature_columns", [])
                self.malware_types = metadata.get("malware_types", [])
                self.feature_importances = metadata.get("feature_importances", {})
            print(f"✅ Enhanced models loaded from: {filepath_prefix}")
            return True
        except Exception as e:
            print(f"❌ Error loading models: {e}")
            return False

class PenetrationTester:
    """Advanced penetration testing module for educational purposes"""
    def __init__(self, malware_database=None):
        self.malware_database = malware_database
        self.attack_signatures = {
            'buffer_overflow': ['high_memory_usage', 'stack_manipulation'],
            'code_injection': ['dynamic_loading', 'memory_writes'],
            'privilege_escalation': ['system_calls', 'kernel_access'],
            'data_exfiltration': ['network_activity', 'file_access'],
            'persistence': ['registry_modification', 'startup_entries'],
            'evasion': ['packing', 'obfuscation', 'anti_debug']
        }
    def comprehensive_penetration_test(self, sample_features, sample_type, prediction_results):
        print(f"\n🔍 === Advanced Penetration Testing: {sample_type} ===")
        pen_test_results = {
            "sample_type": sample_type,
            "attack_surface_analysis": {},
            "vulnerability_assessment": {},
            "exploit_potential": {},
            "defensive_gaps": {},
            "simulation_results": {}
        }
        pen_test_results["attack_surface_analysis"] = self._analyze_attack_surface(
            sample_features, prediction_results
        )
        pen_test_results["vulnerability_assessment"] = self._assess_vulnerabilities(
            sample_features, sample_type
        )
        pen_test_results["exploit_potential"] = self._analyze_exploit_potential(
            sample_features, prediction_results
        )
        pen_test_results["defensive_gaps"] = self._identify_defensive_gaps(
            prediction_results
        )
        pen_test_results["simulation_results"] = self._simulate_attack_scenarios(
            sample_features, prediction_results
        )
        return pen_test_results
    def _analyze_attack_surface(self, features, prediction_results):
        attack_surface = {
            "entry_points": [],
            "exposed_interfaces": [],
            "privilege_requirements": "User",
            "network_exposure": False,
            "local_exposure": True
        }
        if len(features) > 0:
            if any(f > 0 for f in features[:5]):
                attack_surface["network_exposure"] = True
                attack_surface["entry_points"].append("Network Interface")
            if len(features) > 10 and any(f > 10000 for f in features[5:10]):
                attack_surface["privilege_requirements"] = "Administrator"
                attack_surface["entry_points"].append("System Level Access")
            if len(features) > 15:
                attack_surface["entry_points"].append("File System")
                attack_surface["exposed_interfaces"].append("File I/O Operations")
        return attack_surface
    def _assess_vulnerabilities(self, features, sample_type):
        vulnerabilities = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": [],
            "cvss_estimates": {}
        }
        if sample_type == "multiclass":
            if len(features) >= 3:
                if features[0] > 5000000:
                    vulnerabilities["medium"].append({
                        "type": "Resource Exhaustion",
                        "description": "Large file size may cause system resource exhaustion",
                        "cvss": 5.5
                    })
                if len(features) > 1 and features[1] > 7.0:
                    vulnerabilities["high"].append({
                        "type": "Obfuscation/Packing",
                        "description": "High entropy indicates advanced evasion techniques",
                        "cvss": 7.2
                    })
                if len(features) > 2 and features[2] > 20:
                    vulnerabilities["medium"].append({
                        "type": "Complex Functionality",
                        "description": "High import count suggests complex attack capabilities",
                        "cvss": 6.1
                    })
        else:
            if len(features) > 0:
                if np.std(features) > np.mean(features) * 2:
                    vulnerabilities["medium"].append({
                        "type": "Behavioral Anomaly",
                        "description": "Unusual behavioral patterns detected",
                        "cvss": 5.8
                    })
        return vulnerabilities
    def _analyze_exploit_potential(self, features, prediction_results):
        exploit_analysis = {
            "exploitation_difficulty": "Medium",
            "required_privileges": "User",
            "attack_vectors": [],
            "payload_delivery": [],
            "persistence_mechanisms": [],
            "evasion_techniques": []
        }
        if "primary_type" in prediction_results.get("multiclass_prediction", {}):
            malware_type = prediction_results["multiclass_prediction"]["primary_type"]
            if isinstance(malware_type, str) and malware_type.lower() == "trojan":
                exploit_analysis["attack_vectors"].extend([
                    "Social engineering delivery",
                    "Email attachment exploitation",
                    "Drive-by download"
                ])
                exploit_analysis["persistence_mechanisms"].append("Registry modification")
            elif isinstance(malware_type, str) and malware_type.lower() == "worm":
                exploit_analysis["attack_vectors"].extend([
                    "Network propagation",
                    "USB/removable media",
                    "Email spreading"
                ])
                exploit_analysis["payload_delivery"].append("Self-replication")
            elif isinstance(malware_type, str) and malware_type.lower() == "ransomware":
                exploit_analysis["exploitation_difficulty"] = "High"
                exploit_analysis["attack_vectors"].extend([
                    "Encryption payload",
                    "File system manipulation",
                    "Network file shares"
                ])
            elif isinstance(malware_type, str) and malware_type.lower() == "spyware":
                exploit_analysis["evasion_techniques"].extend([
                    "Keylogging",
                    "Screen capture",
                    "Data exfiltration"
                ])
            elif isinstance(malware_type, str) and malware_type.lower() == "rootkit":
                exploit_analysis["required_privileges"] = "Administrator"
                exploit_analysis["evasion_techniques"].extend([
                    "Kernel-level hiding",
                    "System call hooking",
                    "Anti-forensics"
                ])
        return exploit_analysis
    def _identify_defensive_gaps(self, prediction_results):
        gaps = {
            "detection_gaps": [],
            "prevention_gaps": [],
            "response_gaps": [],
            "monitoring_gaps": []
        }
        binary_conf = prediction_results["binary_prediction"].get("malware_probability", 0)
        if binary_conf > 0.5 and binary_conf < 0.8:
            gaps["detection_gaps"].append("Borderline detection - may evade some AV engines")
        if "confidence" in prediction_results.get("multiclass_prediction", {}):
            multi_conf = prediction_results["multiclass_prediction"]["confidence"]
            if multi_conf < 0.7:
                gaps["detection_gaps"].append("Uncertain malware classification - novel variant possible")
        gaps["prevention_gaps"].extend([
            "Static analysis may miss runtime behavior",
            "Signature-based detection may be insufficient"
        ])
        gaps["response_gaps"].extend([
            "Manual analysis required for complex samples",
            "Incident response procedures need validation"
        ])
        gaps["monitoring_gaps"].extend([
            "Real-time behavioral monitoring recommended",
            "Network traffic analysis required"
        ])
        return gaps
    def _simulate_attack_scenarios(self, features, prediction_results):
        scenarios = {
            "scenario_1": {
                "name": "Initial Compromise",
                "description": "Simulating initial system compromise",
                "success_probability": 0.0,
                "mitigation_effectiveness": 0.0
            },
            "scenario_2": {
                "name": "Lateral Movement",
                "description": "Simulating network lateral movement",
                "success_probability": 0.0,
                "mitigation_effectiveness": 0.0
            },
            "scenario_3": {
                "name": "Data Exfiltration",
                "description": "Simulating data theft attempts",
                "success_probability": 0.0,
                "mitigation_effectiveness": 0.0
            },
            "scenario_4": {
                "name": "Persistence",
                "description": "Simulating persistence mechanisms",
                "success_probability": 0.0,
                "mitigation_effectiveness": 0.0
            }
        }
        if prediction_results["binary_prediction"].get("is_malware", False):
            base_probability = prediction_results["binary_prediction"]["malware_probability"]
            scenarios["scenario_1"]["success_probability"] = base_probability * 0.8
            scenarios["scenario_1"]["mitigation_effectiveness"] = 1.0 - base_probability
            scenarios["scenario_2"]["success_probability"] = base_probability * 0.6
            scenarios["scenario_2"]["mitigation_effectiveness"] = 1.0 - (base_probability * 0.6)
            scenarios["scenario_3"]["success_probability"] = base_probability * 0.7
            scenarios["scenario_3"]["mitigation_effectiveness"] = 1.0 - (base_probability * 0.7)
            scenarios["scenario_4"]["success_probability"] = base_probability * 0.5
            scenarios["scenario_4"]["mitigation_effectiveness"] = 1.0 - (base_probability * 0.5)
        else:
            for scenario in scenarios.values():
                scenario["success_probability"] = 0.1
                scenario["mitigation_effectiveness"] = 0.95
        return scenarios

def main():
    print("🛡️ === Enhanced Malware Detection and Classification System ===")
    print("🎓 College Project - Advanced Cybersecurity Educational Tool")
    print("👨‍💻 Developed by: Mohammed Shahir")
    print("🏫 Supervised Academic Project\n")
    detector = EnhancedMalwareDetectionSystem()
    print("📊 Step 1: Loading datasets...")
    binary_df = detector.load_binary_dataset("malware_dataset.csv")
    if binary_df is None:
        print("❌ Failed to load binary dataset. Please ensure 'malware_dataset.csv' exists.")
        return
    multiclass_df = detector.load_multiclass_dataset("malware_classification_dataset.csv")
    if multiclass_df is None:
        print("❌ Failed to load multiclass dataset. Please ensure 'malware_classification_dataset.csv' exists.")
        return
    print("\n🔄 Step 2: Preprocessing datasets...")
    X_binary, y_binary, binary_df_clean = detector.preprocess_binary_data(binary_df)
    X_multiclass, y_multiclass, multiclass_df_clean = detector.preprocess_multiclass_data(multiclass_df)
    # attach label back to multiclass cleaned DF so we can sample by label later
    multiclass_df_clean = multiclass_df_clean.copy()
    multiclass_df_clean['label'] = y_multiclass.values
    if X_binary is None or X_multiclass is None:
        print("❌ Preprocessing failed. Exiting.")
        return
    print("\n🤖 Step 3: Training machine learning models...")
    binary_accuracy = detector.train_binary_classifier(X_binary, y_binary)
    multiclass_accuracy = detector.train_multiclass_classifier(X_multiclass, y_multiclass)
    print("\n💾 Step 4: Saving trained models...")
    detector.save_models()
    pen_tester = PenetrationTester(X_multiclass.values if X_multiclass is not None else None)
    print("\n" + "="*70)
    print("🧪 === COMPREHENSIVE TESTING AND PENETRATION ANALYSIS ===")
    print("="*70)
    print("\n🔴 --- Test 1: Real Malware Sample from Binary Dataset ---")
    malware_samples = binary_df_clean[binary_df_clean['classification'] == 'malware']
    if not malware_samples.empty:
        malware_sample = malware_samples.iloc[0][detector.binary_feature_columns].values
        prediction = detector.predict_comprehensive(malware_sample, "Real_Malware_Sample", "binary")
        print(f"🔍 COMPREHENSIVE ANALYSIS RESULTS:")
        print(f"   📊 Binary Prediction: {'🚨 MALWARE' if prediction['binary_prediction']['is_malware'] else '✅ BENIGN'}")
        print(f"   📈 Malware Probability: {prediction['binary_prediction']['malware_probability']:.3f}")
        if 'primary_type' in prediction.get('multiclass_prediction', {}):
            print(f"   🏷️ Malware Type: {prediction['multiclass_prediction']['primary_type']}")
            print(f"   🎯 Type Confidence: {prediction['multiclass_prediction']['confidence']:.3f}")
            print("   🔝 Top 3 Predictions:")
            for i, pred in enumerate(prediction['multiclass_prediction']['top_predictions'][:3], 1):
                print(f"      {i}. {pred['type']} ({pred['probability']:.3f})")
        print(f"   ⚠️ Penetration Score: {prediction['penetration_analysis']['penetration_score']:.1f}/100")
        print(f"   🛡️ Penetration Level: {prediction['penetration_analysis']['penetration_level']}")
        print(f"   🎯 Overall Threat: {prediction['overall_assessment']['threat_level']}")
        print(f"   📋 Recommended Action: {prediction['overall_assessment']['recommended_action']}")
        pen_results = pen_tester.comprehensive_penetration_test(
            malware_sample, "Real_Malware_Sample", prediction
        )
        print(f"   🔓 Attack Surface: {len(pen_results['attack_surface_analysis'].get('entry_points', []))} entry points")
        print(f"   🎭 Exploit Potential: {pen_results['exploit_potential'].get('exploitation_difficulty', 'Unknown')}")
    print("\n🟢 --- Test 2: Real Benign Sample from Binary Dataset ---")
    benign_samples = binary_df_clean[binary_df_clean['classification'] == 'benign']
    if not benign_samples.empty:
        benign_sample = benign_samples.iloc[0][detector.binary_feature_columns].values
        prediction = detector.predict_comprehensive(benign_sample, "Real_Benign_Sample", "binary")
        print(f"🔍 COMPREHENSIVE ANALYSIS RESULTS:")
        print(f"   📊 Binary Prediction: {'🚨 MALWARE' if prediction['binary_prediction']['is_malware'] else '✅ BENIGN'}")
        print(f"   📈 Malware Probability: {prediction['binary_prediction']['malware_probability']:.3f}")
        print(f"   ⚠️ Penetration Score: {prediction['penetration_analysis']['penetration_score']:.1f}/100")
        print(f"   🛡️ Penetration Level: {prediction['penetration_analysis']['penetration_level']}")
        print(f"   🎯 Overall Threat: {prediction['overall_assessment']['threat_level']}")
        pen_results = pen_tester.comprehensive_penetration_test(
            benign_sample, "Real_Benign_Sample", prediction
        )
        print(f"   🔓 Vulnerability Count: {pen_results['vulnerability_assessment'] and sum(len(v) for v in pen_results['vulnerability_assessment'].values()) or 0}")
        print(f"   🛠️ Defensive Gaps: {len(pen_results['defensive_gaps'].get('detection_gaps', []))}")
    print("\n🟡 --- Test 3: Specific Malware Type from Multiclass Dataset ---")
    # Use the processed multiclass dataframe (multiclass_df_clean) rather than raw multiclass_df
    if 'label' in multiclass_df_clean.columns and not multiclass_df_clean.empty:
        unique_types = pd.unique(multiclass_df_clean['label'])
        for malware_type in unique_types[:3]:
            # select from processed df which contains the encoded/generated columns
            subset = multiclass_df_clean[multiclass_df_clean['label'] == malware_type]
            if subset.empty:
                continue
            type_sample = subset.iloc[0]
            # ensure all expected feature columns exist in the processed DF
            missing_cols = [c for c in detector.multiclass_feature_columns if c not in type_sample.index]
            if missing_cols:
                print(f"   ⚠️ Skipping {malware_type}: missing processed cols {missing_cols}")
                continue
            multiclass_sample = type_sample[detector.multiclass_feature_columns].values
            prediction = detector.predict_comprehensive(
                multiclass_sample, f"{malware_type}_Sample", "multiclass"
            )
            print(f"\n   🔍 {str(malware_type).upper()} ANALYSIS:")
            print(f"      📊 Binary Prediction: {'🚨 MALWARE' if prediction['binary_prediction'].get('is_malware', False) else '✅ BENIGN'}")
            if 'primary_type' in prediction.get('multiclass_prediction', {}):
                predicted_type = prediction['multiclass_prediction']['primary_type']
                confidence = prediction['multiclass_prediction']['confidence']
                print(f"      🏷️ Predicted Type: {predicted_type}")
                print(f"      🎯 Accuracy: {'✅ CORRECT' if predicted_type == malware_type else '❌ INCORRECT'}")
                print(f"      📈 Confidence: {confidence:.3f}")
            print(f"      ⚠️ Penetration Score: {prediction['penetration_analysis']['penetration_score']:.1f}/100")
            print(f"      🎯 Threat Level: {prediction['overall_assessment']['threat_level']}")
            pen_results = pen_tester.comprehensive_penetration_test(
                multiclass_sample, f"{malware_type}_Sample", prediction
            )
    else:
        print("   ⚠️ No processed multiclass data available for Test 3.")
    print("\n🔥 --- Test 4: Advanced Penetration Testing Scenarios ---")
    test_scenarios = [
        {
            "name": "High_Risk_Synthetic",
            "features": np.array([2000000, 7.8, 25, 1, 5000, 15, 45, 8, 1, 5, 3, 2, 1]),
            "description": "Synthetic high-risk malware profile"
        },
        {
            "name": "Medium_Risk_Synthetic",
            "features": np.array([500000, 4.5, 12, 0, 1200, 8, 20, 3, 1, 2, 1, 0, 0]),
            "description": "Synthetic medium-risk profile"
        },
        {
            "name": "Low_Risk_Synthetic",
            "features": np.array([50000, 2.1, 5, 0, 200, 3, 8, 1, 0, 0, 0, 0, 0]),
            "description": "Synthetic low-risk profile"
        }
    ]
    for scenario in test_scenarios:
        print(f"\n   🧪 Testing: {scenario['name']}")
        if len(scenario['features']) != len(detector.multiclass_feature_columns):
            if len(scenario['features']) < len(detector.multiclass_feature_columns):
                additional = np.random.normal(0, 1, len(detector.multiclass_feature_columns) - len(scenario['features']))
                test_features = np.concatenate([scenario['features'], additional])
            else:
                test_features = scenario['features'][:len(detector.multiclass_feature_columns)]
        else:
            test_features = scenario['features']
        prediction = detector.predict_comprehensive(
            test_features, scenario['name'], "multiclass"
        )
        print(f"      📊 Detection: {'🚨 MALWARE' if prediction['binary_prediction'].get('is_malware', False) else '✅ BENIGN'}")
        if 'primary_type' in prediction.get('multiclass_prediction', {}):
            print(f"      🏷️ Type: {prediction['multiclass_prediction']['primary_type']}")
        print(f"      ⚠️ Penetration Score: {prediction['penetration_analysis']['penetration_score']:.1f}/100")
        print(f"      🎯 Threat Level: {prediction['overall_assessment']['threat_level']}")
    print("\n" + "="*80)
    print("🎯 === FINAL SYSTEM PERFORMANCE AND CAPABILITIES SUMMARY ===")
    print("="*80)
    print(f"📈 ACCURACY METRICS:")
    print(f"   • Binary Classification Accuracy: {binary_accuracy:.4f} ({binary_accuracy*100:.1f}%)")
    print(f"   • Multiclass Classification Accuracy: {multiclass_accuracy:.4f} ({multiclass_accuracy*100:.1f}%)")
    print(f"\n🔢 DATASET STATISTICS:")
    print(f"   • Binary Dataset: {binary_df.shape[0]:,} samples, {len(detector.binary_feature_columns)} features")
    print(f"   • Multiclass Dataset: {multiclass_df.shape[0]:,} samples, {len(detector.multiclass_feature_columns)} features")
    print(f"   • Malware Types Detected: {len(detector.malware_types)}")
    print(f"   • Available Malware Types: {list(detector.malware_types)}")
    print(f"\n🛡️ SYSTEM CAPABILITIES:")
    print(f"   ✅ Binary Malware Detection (Malware vs Benign)")
    print(f"   ✅ Multiclass Malware Classification ({len(detector.malware_types)} types)")
    print(f"   ✅ Advanced Penetration Testing Analysis")
    print(f"   ✅ Vulnerability Assessment and Scoring")
    print(f"   ✅ Attack Vector Identification")
    print(f"   ✅ Defensive Gap Analysis")
    print(f"   ✅ Risk-based Recommendations")
    print(f"   ✅ Executive Summary Generation")
    print(f"\n✅ === ENHANCED MALWARE DETECTION SYSTEM READY ===")
    print(f"🛡️ System successfully trained and tested on both datasets!")
    print(f"🎓 Ready for academic demonstration and further development.")
    print(f"🔬 All models saved and available for future use.")

if __name__ == "__main__":
    main()
